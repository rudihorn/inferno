module ML = Lang.ML

type t = ML.term
type typ = ML.ty

(** Thunk to reset the fresh variable counters. Use with caution. *)
val reset : unit -> unit

(** Create a variable reference. This function should generally not be used directly. *)
val var : string -> t

(** Create a frozen variable reference. This prevents generalization from happening.
    This function should generally not be used directly. *)
val frozen : string -> t

(** Create a lambda abstraction. The user supplied function is applied to a term
    corresponding to the variable. If the argument is expected to be a polymorphic
    type then the user can supply a type argument using {typ}.

    The following example creates an id node:
    {|
      abs (fun x -> x)
    |}*)
val abs : ?typ:typ -> (t -> t) -> t

(** Create a lambda abstraction with two arguments. See {abs} for more information. *)
val abs2 : (t -> t -> t) -> t

(** Create a lambda abstraction with two arguments. See {abs} for more information. *)
val abs3 : (t -> t -> t -> t) -> t

(** Function application. *)
val app : t -> t -> t

(** Function application with two arguments. *)
val app2 : t -> t -> t -> t

(** Function application with three arguments. *)
val app3 : t -> t -> t -> t -> t

(** Freezes the variable term supplied to the function. *)
val (~%) : t -> t

(** Generate a fresh type variable and quantify the type generated by the function.

    The following example describes the type of the id function:
    {|
      forall (fun a -> a --> a)
    |}*)
val forall : (typ -> typ) -> typ

(** Creates a function arrow type. *)
val (-->) : typ -> typ -> typ

(** Bind the expression to a fresh variable and use it in the body.

    The following example binds the integer 5 to x and returns it in the body:
    {|
      let@ x = i 5 in
      x
    |}
   *)
val (let@) : t -> (t -> t) -> t

(** Bind the expression to a variable and use it in the body. Use the specified string
    value as the name of the variable. *)
val (let@@) : string * t -> (t -> t) -> t

(** Create a constant integer expression. *)
val i : int -> t

(** Constant true boolean expression. *)
val ctrue : t

(** Constant false boolean expression. *)
val cfalse : t
